<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
    <title>Programação Assíncrona</title>
</head>
<body>
    <h1>Programação Assíncrona</h1>
    <h2>O que é programação assíncrona?</h2>
    <h3>Callback</h3>
    <p>A programação assíncrona acontece de forma que várias ações acontecem ao mesmo tempo, sem uma sequência programática.</p>
    <p>Ex: Um usuário está no checkout, manda salvar seu endereço na conta, mas pode prosseguir para finalizar sem recarregar a página, pois a a ação de adicionar o endereço ocorreu de forma assíncrona.</p>
    <h3>Promises</h3>
    <p>As <strong>promises</strong> são ações assíncronas que podem produzir um valor em algum momento no código, sendo uma forma de dizer a linguagem que um valor pode estar presente em um futuro do código.</p>
    <p>O objeto das promises é o <strong>Promise</strong>, <strong>resolve</strong> é o método que resolve uma promise, o <strong>then</strong> é o que faz ela poder ser executada em um ponto futuro do código.</p>
    <p>EX: <br><br>
        let promessa = Promise.resolve(4 + 8);<br>
        console.log('Algum código');<br>
        promessa.then((value) => console.log(`A soma é ${value}`)) <br>
    </p>
    <h3>Falha no Promises</h3>
    <p>O promises pode falhar e podemos reter esse erros com um método chamado <strong>catch</strong>, com ele podemos exibir o erro no console e fazer um debug no código.</p>
    <p>EX: <br><br>
        let promisesErrada = Primise.resolve(new Error("Algo deu errado")) <br><br>
        promiseErrada <br>
            .then((value) => console.log(value)) <br>
            .catch(reason => console.log("Erro: " + reason)); <br>
    </p>
    <h3>Rejeitando Promises</h3>
    <p>Além do método reslve existe também o método reject, quando uma determinada lógica não satisfaz nosso programa, podemos ir para outra lógica com o <strong>reject</strong> em vez do relove, terminando a promise não podendo mais chamar o then, por exemplo.</p>
    <p>EX: <br>
        function verificarAlgo(num) {
            return new Promise((resole, reject) => {
                if(num == 2) {
                    resolve(console.log("O número é 2"));
                } else {
                    reject(new Error("Falhou"));
                }
            })
        }
        verificarAlgo(3);
        verificarAlgo(4);
    </p>
    <h3>Método All</h3>
    <p>Com o método All podemos resolver todas as promises de uma vez só, ou seja, passamos elas por array e quando a última for resolvida recebemos a resposta.</p>
    <p>EX: <br> <br>
        const p1 = new Promise(function(resolve, reject){ <br>
            setTimeout(function(){ <br>
                resolve(100); <br>
            }, 2500); <br>
        }) <br>
        const p2 = promise.resolve(5);<br>
        const p3 = new Promise(function(resolve, reject) { <br>
            resolve(10); <br>
        });<br>
        promise.all([p1,p2,p3]).then((value)=> console.log(values));
    </p>
    <h3>Async Function</h3>
    <p>Podemos criar funcões assíncronas com a palavra reservada async, elas retornam uma Promise, essa promise é resolvida e se der alguma exception a promise é rejeitada.</p>
    <p>EX: <br>
        async function somar(a,b) {
            return a + b;
        }
        somar(2,2).then(function(value){
            console.log(value);
        });
    </p>
    <h3>Await</h3>
    <p>Nas async function, podemos determinar uma instrução await, que vai esperar uma promise ser resolvida  para apresentar os resultados.</p>
    <p>EX: <br><br>
        function somaComDelay(a,b) { <br>
            return new Promise(resolve => { <br>
                setTimeout(function()) { <br>
                    resolve(a + b); <br>
                }, 2000) ; <br>
            }); <br>
        } <br>
        async function soma(a,b,c,d) { <br>
            let x = somaComDelay(a,b); <br>
            let y = somaComDeley(c,d) <br>
            return await x + await y; <br>
        } <br>
        soma(2,4,6,8).then(x =>console.log(y));
    </p>
    <h3>Generators</h3>
    <p>generators funcionam semelhante as Promises, onde as ações podem ser pausadas e continuadas depois. são caracterizadas pela <strong>function*</strong> e <strong>yield</strong>,onde o yield pode salvar o estado da variável.</p>
    <p>EX: <br><br>
        function* genTest() { <br>
            let id = 0; <br>
            while(true) { <br>
                yield id++; <br>
            } <br>
        } <br>
        let criarId = genTest(); <br>
        console.log(criarId.next().value); <br>
        console.log(criarId.next().value);
    </p>
</body>
</html>